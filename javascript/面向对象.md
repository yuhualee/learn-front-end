Date: 2014-09-16  
Title:原型和原型链   
Published: true  
Type: post  
Excerpt:   

## 1.面向对象

* **1.1 手工模式：单例模式**

	```
	var person = new Object();
	person.name = "lyh";
	person.sex = "female";
	```
	> 1. 问题：创建多个对象，代码重复
	> 2. 解决方法---工厂模式

* **1.2 工厂模式:就是对生产对象的流程进行封装**

	```
function person(name,age){
	var obj = {};
	obj.name = name;
	obj.age = age;
	obj.getName = function(){
		alert(this.name);
	}
	return obj;
}
//批量生产对象
var a = [];
for(var i=0;i<10;i++){
	a.push(person("lyh"+i,18+i));
}
//单独设置
var lyh = new person("李玉华",18);
```

	> 1. 解决了我们批量生产的问题
	> 2. 随着发展我们还要区分产品的差异化----构造函数模式

* **1.3 构造函数**
		
	```
function Person(name,age){
	this.name = name;
	this.age = age;
	this.getName = function(){
		alert(this.name);
	}
}
var p1 = new Person("lyh",18);
var p2 = new Person("李玉华",18);
alert(p1.getName);
alert(p2.getName);
alert(p1.getName==p2.getName);   //false
```



---
---
---


* **基于构造函数的原型模式** 

	我们发现，不管是哪个实例，我们的writeCss或者writeJs其实都是同样的规范，我们不是每次new函数的时候重新的创建，那么我们如何创建了，又不用重复创建呢？
	
	> * object: 创建一个对象数据类型的数据，我们不仅在内存中开辟了一个空间，将自己私有的键值对存进来，而且还有一个系统自带的属性 _ proto _ 
	
	> * function:创建一个函数，我们不仅在内存中开辟了一个空间，将我们函数里面的js代码当成字符串存进去，而且还有一个系统自带的属性：prototype
	
	> * 
```
function constructFn(name,age){
		this.name = name;
		this.age = age;
}
constructFn.prototype.writeCss = function(){
};
constructFn.prototype.writeJs = function(){
};
var p1 = new constructFn("aaa",1);
var p2 = new constructFn("bbb",2);
p1.name;
p1.age;
p1.writeCss;
p1.writeJs;
alert(p1.writeCss==p2.wirteJs);   //指向同一内存，所以地址相同
```
	>* 如果我们的某个实例想获取类中prototype上定义的方法和属性，我们的原理是：实例中默认的 _ proto _ 属性去获取的.
	>* p1.wirteCss();----先在类中私有空间中找这个方法，如果没有的话，才去类的原型链上找，如果有，则不再去原型链上找



---
---

* **重新认识面向对象：**

	1. 一切事物皆对象
	2. 对象具有**封装和继承**的特性
	3. 对象与对象之间存在信息通信，各自存着信息隐藏
	
	javascript是通过原型（**prototype**）的方式来实现面向对象的。
	





